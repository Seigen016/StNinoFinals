{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 40, "column": 0}, "map": {"version":3,"sources":["file:///Users/koyaemer/Development/StNinoFinals/lib/notifications.ts"],"sourcesContent":["// Simple TextBee notifier using fetch\n// Requires the following environment variables:\n// - TEXTBEE_API_KEY: API key for TextBee\n// - TEXTBEE_API_URL: Base URL for TextBee API (e.g., https://api.textbee.com/v1)\n// - TEXTBEE_SENDER_ID: Sender identifier or phone number assigned to your service\n\nexport async function sendSms(phone: string, message: string) {\n  if (!phone) {\n    console.warn('sendSms called without phone number')\n    return false\n  }\n\n  const apiKey = process.env.TEXTBEE_API_KEY\n  const apiUrl = process.env.TEXTBEE_API_URL || 'https://api.textbee.com/v1'\n  const sender = process.env.TEXTBEE_SENDER_ID || process.env.TEXTBEE_SENDER || process.env.SMS_SENDER || null\n\n  if (!apiKey) {\n    console.warn('TEXTBEE_API_KEY is not configured; skipping SMS send')\n    return false\n  }\n\n  try {\n    const url = `${apiUrl.replace(/\\/+$/,'')}/messages`\n    const payload: any = {\n      to: phone,\n      message: message,\n    }\n    if (sender) payload.from = sender\n\n    // Use global fetch (available in Node 18+)\n    const res = await fetch(url, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n        'Authorization': `Bearer ${apiKey}`,\n      },\n      body: JSON.stringify(payload),\n    })\n\n    if (!res.ok) {\n      const text = await res.text()\n      console.error('TextBee API error:', res.status, text)\n      return false\n    }\n\n    try {\n      const data = await res.json()\n      console.log('TextBee sent msg, id:', data?.id || 'unknown')\n    } catch (err) {\n      // non-JSON response, still okay\n    }\n\n    return true\n  } catch (err: any) {\n    console.error('Failed to send SMS using TextBee:', err?.message || err)\n    return false\n  }\n}\n"],"names":[],"mappings":"AAAA,sCAAsC;AACtC,gDAAgD;AAChD,yCAAyC;AACzC,iFAAiF;AACjF,kFAAkF;;;;;AAE3E,eAAe,QAAQ,KAAa,EAAE,OAAe;IAC1D,IAAI,CAAC,OAAO;QACV,QAAQ,IAAI,CAAC;QACb,OAAO;IACT;IAEA,MAAM,SAAS,QAAQ,GAAG,CAAC,eAAe;IAC1C,MAAM,SAAS,QAAQ,GAAG,CAAC,eAAe,IAAI;IAC9C,MAAM,SAAS,QAAQ,GAAG,CAAC,iBAAiB,IAAI,QAAQ,GAAG,CAAC,cAAc,IAAI,QAAQ,GAAG,CAAC,UAAU,IAAI;IAExG,IAAI,CAAC,QAAQ;QACX,QAAQ,IAAI,CAAC;QACb,OAAO;IACT;IAEA,IAAI;QACF,MAAM,MAAM,GAAG,OAAO,OAAO,CAAC,QAAO,IAAI,SAAS,CAAC;QACnD,MAAM,UAAe;YACnB,IAAI;YACJ,SAAS;QACX;QACA,IAAI,QAAQ,QAAQ,IAAI,GAAG;QAE3B,2CAA2C;QAC3C,MAAM,MAAM,MAAM,MAAM,KAAK;YAC3B,QAAQ;YACR,SAAS;gBACP,gBAAgB;gBAChB,iBAAiB,CAAC,OAAO,EAAE,QAAQ;YACrC;YACA,MAAM,KAAK,SAAS,CAAC;QACvB;QAEA,IAAI,CAAC,IAAI,EAAE,EAAE;YACX,MAAM,OAAO,MAAM,IAAI,IAAI;YAC3B,QAAQ,KAAK,CAAC,sBAAsB,IAAI,MAAM,EAAE;YAChD,OAAO;QACT;QAEA,IAAI;YACF,MAAM,OAAO,MAAM,IAAI,IAAI;YAC3B,QAAQ,GAAG,CAAC,yBAAyB,MAAM,MAAM;QACnD,EAAE,OAAO,KAAK;QACZ,gCAAgC;QAClC;QAEA,OAAO;IACT,EAAE,OAAO,KAAU;QACjB,QAAQ,KAAK,CAAC,qCAAqC,KAAK,WAAW;QACnE,OAAO;IACT;AACF"}},
    {"offset": {"line": 134, "column": 0}, "map": {"version":3,"sources":["file:///Users/koyaemer/Development/StNinoFinals/lib/supabaseAdmin.ts"],"sourcesContent":["import { Database } from '@/database.types'\nimport { createClient, type SupabaseClient } from '@supabase/supabase-js'\n\n/**\n * Supabase Admin Client for Server-Side Operations\n * \n * ‚ö†Ô∏è SECURITY WARNING: This client uses the SERVICE ROLE KEY\n * - Bypasses ALL Row Level Security (RLS) policies\n * - Full database access with no restrictions\n * - ONLY use in server-side code (API routes, Server Components)\n * - NEVER import or use in client-side components\n * \n * Use Cases:\n * - Admin operations requiring elevated privileges\n * - System-level database operations\n * - Background jobs and cron tasks\n */\n\nconst supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL\nconst serviceRoleKey = process.env.SUPABASE_SERVICE_ROLE_KEY\n\n/**\n * Creates and returns a Supabase admin client instance\n * \n * @returns SupabaseClient with full admin privileges\n * @throws Error if environment variables are not set\n * \n * @example\n * ```ts\n * // In API route or Server Component only\n * const supabaseAdmin = getSupabaseAdmin();\n * const { data } = await supabaseAdmin.from('users').select('*');\n * ```\n */\nexport function getSupabaseAdmin(): SupabaseClient<Database> {\n  if (!supabaseUrl || !serviceRoleKey) {\n    throw new Error('Missing Supabase admin env. Set NEXT_PUBLIC_SUPABASE_URL and SUPABASE_SERVICE_ROLE_KEY (server-only).')\n  }\n  \n  return createClient<Database>(supabaseUrl as string, serviceRoleKey as string, {\n    auth: {\n      autoRefreshToken: false,\n      persistSession: false,\n    },\n  })\n}\n\n\n"],"names":[],"mappings":";;;;AACA;;AAEA;;;;;;;;;;;;;CAaC,GAED,MAAM;AACN,MAAM,iBAAiB,QAAQ,GAAG,CAAC,yBAAyB;AAerD,SAAS;IACd,IAAI,CAAC,eAAe,CAAC,gBAAgB;QACnC,MAAM,IAAI,MAAM;IAClB;IAEA,OAAO,IAAA,mRAAY,EAAW,aAAuB,gBAA0B;QAC7E,MAAM;YACJ,kBAAkB;YAClB,gBAAgB;QAClB;IACF;AACF"}},
    {"offset": {"line": 176, "column": 0}, "map": {"version":3,"sources":["file:///Users/koyaemer/Development/StNinoFinals/app/api/admin/attendance-live/route.ts"],"sourcesContent":["import { sendSms } from '@/lib/notifications'\nimport { getSupabaseAdmin } from '@/lib/supabaseAdmin'\nimport { NextResponse } from 'next/server'\n\n// Timeout mode tracker: stores expiration timestamp for timeout mode\n// Format: Map<timestamp, expirationTime>\nconst timeoutModeExpiry = new Map<number, number>()\n\n// Clean up expired timeout modes (called on each request instead of setInterval)\n// This avoids issues with setInterval in Next.js serverless functions\nfunction cleanupExpiredTimeouts() {\n  const now = Date.now()\n  for (const [timestamp, expiry] of timeoutModeExpiry.entries()) {\n    if (now > expiry) {\n      timeoutModeExpiry.delete(timestamp)\n    }\n  }\n}\n\n// Check if timeout mode is currently active\nfunction isTimeoutModeActive(): boolean {\n  cleanupExpiredTimeouts() // Clean up before checking\n  const now = Date.now()\n  for (const expiry of timeoutModeExpiry.values()) {\n    if (now < expiry) {\n      return true\n    }\n  }\n  return false\n}\n\n// Enable CORS for ESP32 requests\nexport async function OPTIONS(request: Request) {\n  return new NextResponse(null, {\n    status: 200,\n    headers: {\n      'Access-Control-Allow-Origin': '*',\n      'Access-Control-Allow-Methods': 'GET, POST, PUT, OPTIONS',\n      'Access-Control-Allow-Headers': 'Content-Type',\n    },\n  })\n}\n\nexport async function GET(request: Request) {\n  // Set default headers for all responses\n  const defaultHeaders = {\n    'Content-Type': 'application/json',\n    'Access-Control-Allow-Origin': '*',\n    'Access-Control-Allow-Methods': 'GET, POST, OPTIONS',\n    'Access-Control-Allow-Headers': 'Content-Type',\n  }\n\n  // Wrap everything in try-catch to ensure we always return JSON\n  try {\n    // Debug: Log request info for localhost debugging\n    const url = new URL(request.url)\n    console.log(\"=== GET REQUEST DEBUG ===\")\n    console.log(\"Request URL:\", url.toString())\n    console.log(\"Origin:\", request.headers.get('origin') || 'N/A')\n    console.log(\"Host:\", request.headers.get('host') || 'N/A')\n    console.log(\"Environment:\", process.env.NODE_ENV)\n    console.log(\"=========================\")\n    const { searchParams } = new URL(request.url)\n    const limit = parseInt(searchParams.get('limit') || '50')\n    const since = searchParams.get('since') // Optional: get records since this timestamp\n\n    // Use admin client to avoid RLS UUID/TEXT comparison errors\n    let supabaseClient\n    try {\n      supabaseClient = getSupabaseAdmin()\n    } catch (clientError: any) {\n      console.error('Failed to get Supabase admin client:', clientError)\n      return NextResponse.json({\n        success: true, // Return success with empty records\n        records: [],\n        warning: 'Database client initialization failed',\n        error: process.env.NODE_ENV === 'development' ? clientError?.message : undefined,\n      }, { \n        status: 200, // Always return 200, never 500\n        headers: defaultHeaders,\n      })\n    }\n\n    if (!supabaseClient) {\n      return NextResponse.json({\n        success: true, // Return success with empty records\n        records: [],\n        warning: 'Database client not available',\n      }, { \n        status: 200, // Always return 200, never 500\n        headers: defaultHeaders,\n      })\n    }\n\n    // Fetch recent attendance records\n    // Don't use join to avoid foreign key issues - fetch students separately\n    let data: any[] = []\n    let error: any = null\n    \n    try {\n      console.log('Attempting to fetch attendance records...')\n      console.log('Limit:', limit)\n      console.log('Since:', since)\n      \n      // Try multiple methods to fetch records, handling PGRST200 errors gracefully\n      let querySuccess = false\n      \n      // Method 1: Try RPC function (bypasses PostgREST completely)\n      try {\n        console.log('Method 1: Trying RPC function...')\n        const { data: rpcData, error: rpcError } = await supabaseClient.rpc('get_attendance_records', {\n          record_limit: limit,\n          since_time: since || null\n        })\n        \n        if (!rpcError && rpcData) {\n          data = rpcData as any[]\n          error = null\n          querySuccess = true\n          console.log('‚úì RPC query successful, records:', (data || []).length)\n        } else {\n          console.log('‚úó RPC failed:', rpcError?.message || 'RPC function not found')\n        }\n      } catch (rpcException: any) {\n        console.log('‚úó RPC exception:', rpcException.message)\n      }\n      \n      // Method 2: If RPC failed, try direct query with explicit columns (no joins)\n      if (!querySuccess) {\n        try {\n          console.log('Method 2: Trying direct query with explicit columns...')\n          let directQuery = supabaseClient\n      .from('attendance_records')\n            .select('id, scan_time, scan_type, user_id, rfid_card, rfid_tag, status, time_in, time_out, created_at, device_id')\n      .order('scan_time', { ascending: false })\n      .limit(limit)\n\n    if (since) {\n            directQuery = directQuery.gt('scan_time', since)\n          }\n          \n          const directResult = await directQuery\n          \n          if (!directResult.error && directResult.data) {\n            data = directResult.data || []\n            error = null\n            querySuccess = true\n            console.log('‚úì Direct query (minimal) successful, records:', (data || []).length)\n          } else {\n            // Check if it's a PGRST200 error - if so, just return empty\n            if (directResult.error?.code === 'PGRST200' || \n                directResult.error?.message?.includes('relationship') ||\n                directResult.error?.message?.includes('Could not find a relationship')) {\n              console.log('‚ö† PostgREST relationship error - returning empty records (this is OK)')\n              data = []\n              error = null\n              querySuccess = true // Treat as success with empty data\n            } else {\n              throw directResult.error\n            }\n          }\n        } catch (directError: any) {\n          // If it's a relationship error, return empty records\n          if (directError.code === 'PGRST200' || \n              directError.message?.includes('relationship') ||\n              directError.message?.includes('Could not find a relationship')) {\n            console.log('‚ö† PostgREST relationship error in catch - returning empty records')\n            data = []\n            error = null\n            querySuccess = true\n          } else {\n            console.error('‚úó Direct query failed:', directError)\n            // Return empty records anyway\n            data = []\n            error = null\n            querySuccess = true\n          }\n        }\n      }\n      \n      // If we still don't have success, return empty records\n      if (!querySuccess) {\n        console.log('‚ö† All query methods failed - returning empty records')\n        data = []\n        error = null\n      }\n    } catch (queryError: any) {\n      console.error('Query execution exception:', queryError)\n      console.error('Exception name:', queryError.name)\n      console.error('Exception message:', queryError.message)\n      console.error('Exception stack:', queryError.stack)\n      error = queryError\n    }\n\n    if (error) {\n      console.error('Database error:', error)\n      console.error('Error code:', error.code)\n      console.error('Error message:', error.message)\n      console.error('Error details:', error.details)\n      console.error('Error hint:', error.hint)\n      \n      // Return empty records instead of failing completely\n      // This allows the frontend to still work even if there's a database issue\n      return NextResponse.json({\n        success: true, // Return success with empty records\n        records: [],\n        warning: 'Unable to fetch attendance records from database',\n        error: process.env.NODE_ENV === 'development' ? error.message : undefined,\n        details: process.env.NODE_ENV === 'development' ? {\n          code: error.code,\n          message: error.message,\n          details: error.details,\n          hint: error.hint,\n        } : undefined,\n      }, { \n        status: 200, // Return 200 with empty records instead of 500\n        headers: {\n          'Content-Type': 'application/json',\n          'Access-Control-Allow-Origin': '*',\n          'Access-Control-Allow-Methods': 'GET, POST, OPTIONS',\n          'Access-Control-Allow-Headers': 'Content-Type',\n        },\n      })\n    }\n\n    // Fetch student and teacher information for all records\n    const studentIds = [...new Set((data || []).map((r: any) => r.user_id).filter(Boolean))]\n    const studentMap: Record<string, any> = {}\n    const teacherMap: Record<string, any> = {}\n    \n    if (studentIds.length > 0) {\n      try {\n        // Fetch all students from users table\n        const { data: allStudents, error: studentsError } = await supabaseClient\n          .from('users')\n          .select('*')\n          .eq('role', 'student')\n          .limit(1000)\n        \n        if (!studentsError && allStudents) {\n          allStudents.forEach((student: any) => {\n            const studentNumberStr = (student.student_number || '').toString().trim()\n            const studentIdUuid = (student.id || '').toString().trim()\n            \n            if (studentNumberStr) studentMap[studentNumberStr] = student\n            if (studentIdUuid) studentMap[studentIdUuid] = student\n          })\n        }\n        \n        // Also fetch teachers\n        const { data: allTeachers, error: teachersError } = await supabaseClient\n          .from('users')\n          .select('*')\n          .eq('role', 'teacher')\n          .limit(1000)\n        \n        if (!teachersError && allTeachers) {\n          allTeachers.forEach((teacher: any) => {\n            const teacherIdUuid = (teacher.id || '').toString().trim()\n            const teacherEmail = (teacher.email || '').toString().trim().toLowerCase()\n            const employeeNum = (teacher.employee_number || '').toString().trim()\n            \n            if (teacherIdUuid) teacherMap[teacherIdUuid] = teacher\n            if (teacherEmail) teacherMap[teacherEmail] = teacher\n            if (employeeNum) teacherMap[employeeNum] = teacher\n          })\n        }\n      } catch (fetchError: any) {\n        console.error('Error fetching students/teachers:', fetchError)\n        // Continue without info\n      }\n    }\n\n    // If we have no data, return empty array\n    if (!data || !Array.isArray(data) || data.length === 0) {\n      console.log('üì≠ No attendance records found in database')\n      console.log('üí° This could mean:')\n      console.log('   1. No scans have been recorded yet')\n      console.log('   2. Database table is empty')\n      console.log('   3. ESP32 scans are not being saved (check POST endpoint logs)')\n      return NextResponse.json({\n        success: true,\n        records: [],\n        message: 'No attendance records found. Scans will appear here once recorded.'\n      }, {\n        status: 200,\n        headers: defaultHeaders,\n      })\n    }\n    \n    console.log(`‚úÖ Found ${(data || []).length} attendance records`)\n    if ((data || []).length > 0) {\n      console.log('üìÖ Sample record times:', data.slice(0, 3).map((r: any) => ({\n        scan_time: r.scan_time,\n        created_at: r.created_at,\n        id: r.id\n      })))\n    }\n\n    // Format the response\n    const formattedRecords = (data || []).map((record: any) => {\n      // Determine scan type from database fields\n      let scanType: 'timein' | 'timeout' | null = null\n      \n      if (record.time_in && record.scan_time === record.time_in) {\n        scanType = 'timein'\n      } else if (record.time_out && record.scan_time === record.time_out) {\n        scanType = 'timeout'\n      } else if (record.scan_type) {\n        scanType = record.scan_type.toLowerCase() === 'time_in' || record.scan_type.toLowerCase() === 'timein' ? 'timein' : \n                   record.scan_type.toLowerCase() === 'time_out' || record.scan_type.toLowerCase() === 'timeout' ? 'timeout' : null\n      } else if (record.type) {\n        scanType = record.type.toLowerCase() === 'time_in' || record.type.toLowerCase() === 'timein' ? 'timein' : \n                   record.type.toLowerCase() === 'time_out' || record.type.toLowerCase() === 'timeout' ? 'timeout' : null\n      }\n      \n      // Get student or teacher info from maps\n      const student = studentMap[record.user_id] || null\n      const teacher = teacherMap[record.user_id] || null\n      \n      // Determine if this is a teacher or student\n      const isTeacher = !!teacher || (student && (\n        student.role === 'teacher' || \n        student.user_type === 'teacher' ||\n        (!student.student_number)\n      ))\n      \n      const person = teacher || student\n      \n      // Debug: Log the record to see what RFID fields are populated\n      console.log('üìã Formatting record:', {\n        id: record.id,\n        user_id: record.user_id,\n        rfid_card: record.rfid_card,\n        rfid_tag: record.rfid_tag,\n        person_found: !!person,\n        person_name: person ? `${person.first_name} ${person.last_name}` : 'None'\n      })\n      \n      return {\n      id: record.id,\n        studentId: record.user_id,\n        studentName: person\n          ? `${person.first_name || ''} ${person.middle_name || ''} ${person.last_name || ''}`.trim() || 'Unknown'\n          : 'Unknown',\n        gradeLevel: isTeacher ? null : (person?.grade_level || 'N/A'),\n        section: isTeacher ? null : (person?.section || 'N/A'),\n      scanTime: record.scan_time || record.created_at,\n      status: record.status || 'Present',\n      rfidCard: record.rfid_card || record.rfid_tag || 'N/A',\n        studentPhoto: person?.photo_url || null,\n        scanType: scanType,\n        timeIn: record.time_in || null,\n        timeOut: record.time_out || null,\n        isTeacher: isTeacher || false,\n        subject: isTeacher ? (person?.specialization || person?.department || 'N/A') : null,\n        role: person?.role || null,\n      }\n    })\n\n    console.log(`üì§ Returning ${(formattedRecords || []).length} formatted records to frontend`)\n    if ((formattedRecords || []).length > 0) {\n      console.log('üìÖ First record scan time:', formattedRecords[0]?.scanTime)\n      console.log('üìÖ Last record scan time:', formattedRecords[formattedRecords.length - 1]?.scanTime)\n    }\n\n    return NextResponse.json({\n      success: true,\n      records: formattedRecords,\n      count: formattedRecords.length,\n    }, {\n      status: 200,\n      headers: defaultHeaders,\n    })\n  } catch (error: any) {\n    console.error('Attendance records API error:', error)\n    console.error('Error stack:', error?.stack)\n    console.error('Error name:', error?.name)\n    console.error('Error message:', error?.message)\n    \n    // Always return JSON, never let Next.js return HTML error page\n    try {\n      return NextResponse.json(\n        {\n          success: true, // Return success with empty records to prevent frontend crash\n          records: [],\n          warning: 'Unable to fetch attendance records',\n          error: error?.message || 'Internal server error',\n          details: process.env.NODE_ENV === 'development' ? {\n            stack: error?.stack,\n            name: error?.name,\n            message: error?.message,\n          } : undefined,\n        },\n        { \n          status: 200, // Return 200 to prevent frontend from treating it as an error\n          headers: defaultHeaders,\n        }\n      )\n    } catch (jsonError: any) {\n      // Even if JSON creation fails, return a simple text response as JSON\n      console.error('Failed to create JSON response:', jsonError)\n      return new NextResponse(\n        JSON.stringify({\n          success: true,\n          records: [],\n          warning: 'Service temporarily unavailable',\n        }),\n        {\n          status: 200,\n          headers: defaultHeaders,\n        }\n      )\n    }\n  }\n}\n\nexport async function POST(request: Request) {\n  // Set default headers for all responses\n  const postHeaders = {\n    'Content-Type': 'application/json',\n    'Access-Control-Allow-Origin': '*',\n    'Access-Control-Allow-Methods': 'GET, POST, OPTIONS',\n    'Access-Control-Allow-Headers': 'Content-Type',\n  }\n\n  // Wrap everything in try-catch to ensure we always return JSON (for Vercel)\n  try {\n    // Debug: Log environment variables\n    console.log(\"=== POST: ENVIRONMENT VARIABLES DEBUG ===\")\n    console.log(\"URL:\", process.env.NEXT_PUBLIC_SUPABASE_URL ? \"SET\" : \"MISSING\")\n    console.log(\"URL Value:\", process.env.NEXT_PUBLIC_SUPABASE_URL)\n    console.log(\"ANON:\", process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY ? \"SET\" : \"MISSING\")\n    console.log(\"ANON Key (first 20 chars):\", process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY?.substring(0, 20) || \"MISSING\")\n    console.log(\"SERVICE:\", process.env.SUPABASE_SERVICE_ROLE_KEY ? \"SET\" : \"MISSING\")\n    console.log(\"SERVICE Key (first 20 chars):\", process.env.SUPABASE_SERVICE_ROLE_KEY?.substring(0, 20) || \"MISSING\")\n    console.log(\"==========================================\")\n\n    let scanData: any = null\n    try {\n      scanData = await request.json()\n    } catch (jsonError: any) {\n      console.error('Error parsing request JSON:', jsonError)\n      return NextResponse.json(\n        { \n          success: false, \n          error: 'Invalid JSON in request body',\n          message: 'Please ensure the request contains valid JSON',\n        },\n        { \n          status: 200,\n          headers: postHeaders,\n        }\n      )\n    }\n    \n    if (!scanData) {\n      return NextResponse.json(\n        { \n          success: false, \n          error: 'Request body is required',\n          message: 'Please include RFID card data in the request',\n        },\n        { \n          status: 200,\n          headers: postHeaders,\n        }\n      )\n    }\n    \n    // Validate required fields\n    if (!scanData.studentId && !scanData.rfidCard) {\n      return NextResponse.json(\n          { \n            success: false, \n            error: 'Student ID or RFID Card is required',\n            records: [],\n          },\n          {\n            status: 200, // Return 200 to prevent frontend crash, but include error in response\n            headers: {\n              'Content-Type': 'application/json',\n              'Access-Control-Allow-Origin': '*',\n              'Access-Control-Allow-Methods': 'GET, POST, OPTIONS',\n              'Access-Control-Allow-Headers': 'Content-Type',\n            },\n          }\n        )\n      }\n\n    // Use admin client for inserts to bypass RLS policies\n    // This avoids UUID/TEXT comparison errors in RLS policies\n    const supabaseClient = getSupabaseAdmin()\n    \n    if (!supabaseClient) {\n        console.error('Supabase client not initialized')\n        if (process.env.NODE_ENV === 'development') {\n          return NextResponse.json({\n            success: true,\n            message: 'Scan recorded (dev mode - not saved to database)',\n          })\n        }\n        return NextResponse.json(\n          { \n            success: false, \n            error: 'Database service not configured. Please check your environment variables.',\n            records: [],\n          },\n          { \n            status: 200, // Return 200 with error message instead of 500\n            headers: {\n              'Content-Type': 'application/json',\n              'Access-Control-Allow-Origin': '*',\n              'Access-Control-Allow-Methods': 'GET, POST, OPTIONS',\n              'Access-Control-Allow-Headers': 'Content-Type',\n            },\n          }\n        )\n      }\n\n      // Get current date (start of day) for checking existing records\n      const today = new Date()\n      today.setHours(0, 0, 0, 0)\n      const todayStart = today.toISOString()\n      const todayEnd = new Date(today)\n      todayEnd.setHours(23, 59, 59, 999)\n      const todayEndISO = todayEnd.toISOString()\n\n      // Find student by RFID card or student ID\n      let studentId = scanData.studentId\n      if (!studentId && scanData.rfidCard) {\n        // Normalize RFID card - remove spaces, convert to uppercase, remove leading zeros\n        let rfidNormalized = scanData.rfidCard.toString().trim().toUpperCase().replace(/\\s+/g, '')\n        // Also create version without leading zeros for matching\n        const rfidNoLeadingZeros = rfidNormalized.replace(/^0+/, '')\n        \n        console.log(`Searching for student with RFID: ${rfidNormalized} (also trying: ${rfidNoLeadingZeros})`)\n        \n        // Fetch all students and filter in memory to avoid column errors\n        const { data: allStudents, error: fetchError } = await supabaseClient\n          .from('users')\n          .select('*')\n          .eq('role', 'student')\n          .limit(1000)\n\n        if (fetchError) {\n          console.error('Error fetching students:', fetchError)\n          return NextResponse.json(\n            { \n              success: false, \n              error: `Database error: ${fetchError.message}`,\n              searchedRfid: rfidNormalized,\n              records: [],\n            },\n            { \n              status: 200, // Return 200 with error message instead of 500\n              headers: {\n                'Content-Type': 'application/json',\n                'Access-Control-Allow-Origin': '*',\n                'Access-Control-Allow-Methods': 'GET, POST, OPTIONS',\n                'Access-Control-Allow-Headers': 'Content-Type',\n              },\n            }\n          )\n        }\n\n        // FIRST check teachers table (prioritize teachers over students if same RFID)\n        // This ensures teacher scans are recorded as teachers, not students\n        console.log(`Checking teachers first for RFID: ${rfidNormalized}`)\n        const { data: allTeachers, error: teachersError } = await supabaseClient\n          .from('users')\n          .select('*')\n          .eq('role', 'teacher')\n          .limit(1000)\n        \n        let matchedTeacher = null\n        if (!teachersError && allTeachers) {\n          // Filter teachers in memory by RFID\n          const teachers = (allTeachers || []).filter((teacher: any) => {\n            const rfid = (teacher.rfid || '').toString().trim().toUpperCase()\n            \n            return rfid === rfidNormalized || rfid === rfidNoLeadingZeros ||\n                   rfid.includes(rfidNormalized)\n          })\n          \n          if (teachers && teachers.length > 0) {\n            matchedTeacher = teachers[0]\n            console.log(`‚úÖ Found teacher FIRST: ${matchedTeacher.first_name || 'Unknown'} ${matchedTeacher.last_name || ''}`)\n            // Use UUID id for attendance_records.user_id (must be UUID, not employee_number)\n            studentId = matchedTeacher.id?.toString()\n            \n            if (!studentId) {\n              console.error('‚ùå Teacher found but has no UUID:', matchedTeacher)\n              return NextResponse.json(\n                { \n                  success: false, \n                  error: 'Teacher record is invalid (missing UUID). Please contact administrator.',\n                },\n                { \n                  status: 200,\n                  headers: postHeaders,\n                }\n              )\n            }\n          }\n        }\n        \n        // If no teacher found, check students table\n        if (!matchedTeacher) {\n          console.log(`No teacher found, checking students for RFID: ${rfidNormalized}`)\n          \n          // Filter students in memory by RFID\n          const students = (allStudents || []).filter((student: any) => {\n            const rfid = (student.rfid || '').toString().trim().toUpperCase()\n            \n            // Check exact matches first, then partial\n            return rfid === rfidNormalized || rfid === rfidNoLeadingZeros ||\n                   rfid.includes(rfidNormalized)\n          })\n\n          if (!students || students.length === 0) {\n            // Neither student nor teacher found\n            console.log(`‚ùå No student or teacher found with RFID: ${rfidNormalized}`)\n            return NextResponse.json(\n              { \n                success: false, \n                error: `No student or teacher found for RFID: ${rfidNormalized}. Please assign this RFID card in the admin panel.`,\n                searchedRfid: rfidNormalized,\n                message: `RFID ${rfidNormalized} not assigned to any student or teacher`\n              },\n              { \n                status: 404,\n                headers: {\n                  'Access-Control-Allow-Origin': '*',\n                  'Access-Control-Allow-Methods': 'GET, POST, OPTIONS',\n                  'Access-Control-Allow-Headers': 'Content-Type',\n                },\n              }\n            )\n          } else {\n            // Found a student\n            const matchedStudent = students[0]\n            console.log(`Found student: ${matchedStudent.first_name || 'Unknown'} ${matchedStudent.last_name || ''}`)\n            \n            // Use UUID id for attendance_records.user_id (must be UUID, not student_number)\n            studentId = matchedStudent.id?.toString()\n            \n            if (!studentId) {\n              console.error('‚ùå Student found but has no UUID:', matchedStudent)\n              return NextResponse.json(\n                { \n                  success: false, \n                  error: 'Student record is invalid (missing UUID). Please contact administrator.',\n                },\n                { \n                  status: 200,\n                  headers: postHeaders,\n                }\n              )\n            }\n          }\n        }\n      }\n\n      // Check if student has already scanned in today\n      // user_id is UUID type referencing users.id\n      let todayRecords: any[] = []\n      let checkError: any = null\n      \n      // Fetch all records for today, then filter in memory to avoid type mismatch\n      const { data: allTodayRecords, error: fetchError } = await supabaseClient\n        .from('attendance_records')\n        .select('id, scan_type, scan_time, time_in, time_out, user_id')\n        .gte('scan_time', todayStart)\n        .lte('scan_time', todayEndISO)\n        .order('scan_time', { ascending: true })\n      \n      if (fetchError) {\n        checkError = fetchError\n        console.error('Error fetching today records:', fetchError)\n      } else if (allTodayRecords) {\n        // Filter in memory by user_id (UUID match)\n        todayRecords = allTodayRecords.filter((r: any) => {\n          const rId = (r.user_id || '').toString().trim()\n          const sId = (studentId || '').toString().trim()\n          return rId === sId || rId === studentId || sId === r.user_id\n        })\n      }\n\n      if (checkError) {\n        console.error('Error checking existing records:', checkError)\n      }\n\n      // Check if student has already timed in and/or timed out today\n      const hasTimeIn = todayRecords.some((r: any) => \n        r.scan_type === 'timein' || r.scan_type === 'time_in' || r.time_in\n      )\n      const hasTimeOut = todayRecords.some((r: any) => \n        r.scan_type === 'timeout' || r.scan_type === 'time_out' || r.time_out\n      )\n\n      // If student has already timed in AND timed out today, reject the scan\n      if (hasTimeIn && hasTimeOut) {\n        console.log('‚ö†Ô∏è Student has already timed in and out today')\n        return NextResponse.json({\n          success: false,\n          message: 'You have completed your attendance for today.',\n          error: 'Already completed attendance for today',\n          hasTimeIn: true,\n          hasTimeOut: true,\n        }, {\n          status: 200,\n          headers: postHeaders,\n        })\n      }\n\n      // Determine scan type\n      const currentTime = new Date().toISOString()\n      let scanType: 'timein' | 'timeout' = 'timein'\n      let timeIn = null\n      let timeOut = null\n\n      // Check if timeout mode is active (button was clicked in display page)\n      const timeoutModeActive = isTimeoutModeActive()\n      \n      if (hasTimeIn && !hasTimeOut) {\n        // Student has timed in but not timed out - force timeout\n        scanType = 'timeout'\n        timeOut = currentTime\n        \n        // Find the most recent time in record for this student today\n        const timeInRecord = todayRecords\n          .filter((r: any) => r.scan_type === 'timein' || r.scan_type === 'time_in')\n          .sort((a: any, b: any) => new Date(b.scan_time).getTime() - new Date(a.scan_time).getTime())[0]\n        \n        if (timeInRecord) {\n          timeIn = timeInRecord.time_in || timeInRecord.scan_time\n        }\n        \n        console.log('‚è∞ Student already timed in today - forcing timeout')\n      } else if (timeoutModeActive && !hasTimeIn) {\n        // Timeout mode active but no time in yet - ignore timeout mode and record as time in\n        scanType = 'timein'\n        timeIn = currentTime\n        console.log('‚ö†Ô∏è Timeout mode active but no time in yet - recording as time in')\n      } else if (timeoutModeActive && hasTimeIn) {\n        // Timeout mode active and has time in - record as timeout\n        scanType = 'timeout'\n        timeOut = currentTime\n        \n        const timeInRecord = todayRecords\n          .filter((r: any) => r.scan_type === 'timein' || r.scan_type === 'time_in')\n          .sort((a: any, b: any) => new Date(b.scan_time).getTime() - new Date(a.scan_time).getTime())[0]\n        \n        if (timeInRecord) {\n          timeIn = timeInRecord.time_in || timeInRecord.scan_time\n        }\n        \n        console.log('‚è∞ Timeout mode active with existing time in - recording as timeout')\n      } else {\n        // Default: record as time in\n        scanType = 'timein'\n        timeIn = currentTime\n        console.log('‚úÖ Recording as time in (default)')\n      }\n\n      // Insert the attendance record\n      // Build insert object with all required fields\n      const attendanceRecord: any = {\n        user_id: studentId,\n      }\n      \n      // Add RFID fields - set both rfid_card and rfid_tag to avoid NOT NULL constraint errors\n      const rfidValue = scanData.rfidCard || ''\n      if (rfidValue) {\n        attendanceRecord.rfid_card = rfidValue\n        attendanceRecord.rfid_tag = rfidValue  // Some schemas use rfid_tag instead\n      } else {\n        // If no RFID provided, set empty string to avoid NOT NULL constraint\n        attendanceRecord.rfid_card = ''\n        attendanceRecord.rfid_tag = ''\n      }\n      \n      // Set device_id - if column is UUID type, we can't use text, so set to null\n      // If column is TEXT type, we can use a device identifier\n      // For now, don't set it to avoid UUID type errors\n      // attendanceRecord.device_id = scanData.deviceId || null\n      \n      attendanceRecord.scan_time = currentTime\n      attendanceRecord.scan_type = scanType\n      attendanceRecord.time_in = timeIn\n      attendanceRecord.time_out = timeOut\n      attendanceRecord.status = scanType === 'timein' ? 'Present' : 'Present'\n      attendanceRecord.created_at = currentTime\n      \n      // Optional type field for compatibility\n      attendanceRecord.type = scanType\n      \n      // Insert the attendance record (without join to avoid foreign key issues)\n      console.log('üíæ Inserting attendance record:', {\n        user_id: attendanceRecord.user_id,\n        rfid_card: attendanceRecord.rfid_card,\n        scan_type: attendanceRecord.scan_type,\n        scan_time: attendanceRecord.scan_time\n      })\n      \n      const { data: newRecord, error: insertError } = await supabaseClient\n        .from('attendance_records')\n        .insert([attendanceRecord])\n        .select('*, users(*)')\n        .single()\n\n      if (insertError) {\n        console.error('‚ùå Insert failed:', insertError)\n        console.error('Database error:', insertError)\n        \n        // In development, return success even if table doesn't exist\n        if (process.env.NODE_ENV === 'development') {\n          console.log('Scan data (dev mode):', { studentId, scanType, timeIn, timeOut })\n          return NextResponse.json({\n            success: true,\n            message: 'Scan recorded (dev mode - not saved to database)',\n            scanType,\n            timeIn,\n            timeOut,\n          }, {\n            headers: {\n              'Access-Control-Allow-Origin': '*',\n              'Access-Control-Allow-Methods': 'GET, POST, OPTIONS',\n              'Access-Control-Allow-Headers': 'Content-Type',\n            },\n          })\n        }\n        \n        return NextResponse.json(\n          { \n            success: false, \n            error: insertError.message,\n            hint: 'Please check that all required columns exist in attendance_records table. Run create-attendance-table.sql in Supabase.',\n            records: [],\n          },\n          { \n            status: 200, // Return 200 with error message instead of 500\n            headers: {\n              'Content-Type': 'application/json',\n              'Access-Control-Allow-Origin': '*',\n              'Access-Control-Allow-Methods': 'GET, POST, OPTIONS',\n              'Access-Control-Allow-Headers': 'Content-Type',\n            },\n          }\n        )\n      }\n\n      // Fetch student or teacher information separately to avoid join issues\n      // Fetch all students and filter in memory to avoid UUID/TEXT comparison errors\n      let personInfo: any = null\n      let isTeacher = false\n      \n      if (studentId) {\n        // First, try to find in users table as student\n        const { data: allStudents } = await supabaseClient\n          .from('users')\n          .select('*')\n          .eq('role', 'student')\n          .limit(1000)\n        \n        if (allStudents) {\n          // Find matching student by comparing as strings\n          const studentIdStr = (studentId || '').toString().trim()\n          personInfo = allStudents.find((student: any) => {\n            const sNum = (student.student_number || '').toString().trim()\n            const sUuid = (student.id || '').toString().trim()\n            return sNum === studentIdStr || sUuid === studentIdStr\n          }) || null\n        }\n        \n        // If not found in students, try users table as teacher\n        if (!personInfo) {\n          const { data: allTeachers } = await supabaseClient\n            .from('users')\n            .select('*')\n            .eq('role', 'teacher')\n            .limit(1000)\n          \n          if (allTeachers) {\n            const personIdStr = (studentId || '').toString().trim()\n            personInfo = allTeachers.find((teacher: any) => {\n              const tNum = (teacher.employee_number || '').toString().trim()\n              const tUuid = (teacher.id || '').toString().trim()\n              const tEmail = (teacher.email || '').toString().trim().toLowerCase()\n              return tNum === personIdStr || tUuid === personIdStr || tEmail === personIdStr\n            }) || null\n            \n            if (personInfo) {\n              isTeacher = true\n            }\n          }\n        }\n      }\n\n      // Format the response\n      const formattedRecord = {\n        id: newRecord.id,\n        studentId: newRecord.users?.student_number || studentId,\n        studentName: personInfo\n          ? `${personInfo.first_name || personInfo.firstName || ''} ${personInfo.last_name || personInfo.lastName || ''}`.trim() || personInfo.name || 'Unknown'\n          : 'Unknown',\n        gradeLevel: isTeacher ? null : (personInfo?.grade_level || personInfo?.gradeLevel || 'N/A'),\n        section: isTeacher ? null : (personInfo?.section || 'N/A'),\n        scanTime: newRecord.scan_time || newRecord.created_at,\n        status: newRecord.status || 'Present',\n        rfidCard: newRecord.rfid_card || scanData.rfidCard || 'N/A',\n        studentPhoto: personInfo?.photo_url || personInfo?.profile_picture || personInfo?.picture || null,\n        scanType: scanType,\n        timeIn: newRecord.time_in || null,\n        timeOut: newRecord.time_out || null,\n        isTeacher: isTeacher,\n        subject: isTeacher ? (personInfo?.subject || personInfo?.subjects || personInfo?.subject_taught || 'N/A') : null,\n      }\n\n      console.log('‚úÖ Scan saved successfully!', {\n        id: newRecord.id,\n        student: formattedRecord.studentName,\n        scanType: scanType,\n        scanTime: formattedRecord.scanTime\n      })\n\n      // === SMS Notification: send to student's parent/guardian ===\n      try {\n        // Only notify for student scans (not teachers) and only on time-in\n        if (!isTeacher && scanType === 'timein') {\n          // Attempt to find parent phone number\n          let parentPhone: string | null = null\n\n          // 1) Look up parent(s) from the `parents` table by student parent_id, parent_email, or parent_students linkage\n          try {\n            const parentRecords: any[] = []\n\n            // If the student record contains a parent_id, prefer that\n            const parentId = personInfo?.parent_id || personInfo?.parentId || null\n            if (parentId) {\n              const { data: parentRecord, error: pErr } = await supabaseClient\n                .from('users')\n                .select('id, phone, mobile, phone_number, email')\n                .eq('id', parentId)\n                .eq('role','parent')\n                .limit(1)\n                .single()\n              if (!pErr && parentRecord) parentRecords.push(parentRecord)\n            }\n\n            // If parent not found but parent_email exists on student, check parents by email\n            const parentEmail = personInfo?.parent_email || personInfo?.parentEmail || null\n            if (!parentRecords.length && parentEmail) {\n              const { data: parentRecord2, error: pErr2 } = await supabaseClient\n                .from('users')\n                .select('id, phone, mobile, phone_number, email')\n                .ilike('email', parentEmail)\n                .limit(1)\n                .single()\n              if (!pErr2 && parentRecord2) parentRecords.push(parentRecord2)\n            }\n\n            // If still not found, look up linkage table parent_students (if exists) for this student (match by student id / student_number / uuid)\n            if (!parentRecords.length && (personInfo?.student_id || personInfo?.student_number || personInfo?.id)) {\n              const sId = personInfo?.student_id || personInfo?.student_number || personInfo?.id\n              try {\n                const { data: linkedParentIds } = await supabaseClient\n                  .from('parent_students')\n                  .select('parent_id')\n                  .eq('student_id', sId)\n                  .limit(10)\n                if (linkedParentIds && linkedParentIds.length > 0) {\n                  // fetch parents by those ids\n                  const parentIds = linkedParentIds.map((r: any) => r.parent_id).filter(Boolean)\n                  if (parentIds.length > 0) {\n                    const { data: parentsFromLink } = await supabaseClient\n                      .from('parents')\n                      .select('id, phone, mobile, phone_number, email')\n                      .in('id', parentIds)\n                    if (parentsFromLink) parentRecords.push(...parentsFromLink)\n                  }\n                }\n              } catch (linkError) {\n                // ignore if parent_students doesn't exist\n              }\n            }\n\n            // If we found any parent records, prefer the first parent's phone\n            if (parentRecords && parentRecords.length > 0) {\n              const p = parentRecords[0]\n              parentPhone = p?.phone || p?.mobile || p?.phone_number || null\n            }\n          } catch (parentQueryError) {\n            console.warn('Unable to query parents table for phone number:', parentQueryError)\n          }\n\n          // 2) If not found, try to derive from student record fields\n          if (!parentPhone && personInfo) {\n            const possibleParentFields = [\n              'parent_phone',\n              'parentPhone',\n              'parent_contact',\n              'parentContact',\n              'parent_mobile',\n              'parentMobile',\n              'phone', // this might be the parent's phone depending on schema\n              'emergency_contact',\n              'emergencyContact'\n            ]\n            for (const f of possibleParentFields) {\n              const val = personInfo[f]\n              if (val) {\n                parentPhone = val\n                break\n              }\n            }\n          }\n\n          // Normalize phone if found and send SMS using TextBee (if configured)\n          if (parentPhone) {\n            // Respect global toggle to disable SMS in development or if not desired\n            const smsEnabled = (process.env.SMS_ON_SCAN_ENABLED || 'false').toLowerCase()\n            if (smsEnabled !== 'true' && smsEnabled !== '1') {\n              console.log('SMS notifications are disabled (SMS_ON_SCAN_ENABLED is not set to true)')\n            } else {\n              // Basic normalization: ensure phone starts with + (assume local country code if not) - only light touch\n              let toPhone = parentPhone.toString().trim()\n              if (!toPhone.startsWith('+')) {\n                // Optionally, set default country code if provided in env\n                const defaultCountryCode = process.env.DEFAULT_PHONE_COUNTRY_CODE || ''\n                if (defaultCountryCode) {\n                  toPhone = `${defaultCountryCode}${toPhone}`\n                }\n              }\n\n              const smsTemplate = process.env.SMS_ON_SCAN_TEMPLATE || 'Dear parent, {studentName} ({gradeLevel} - {section}) was recorded present at {scanTime}. ‚Äî Sto Ni√±o Portal'\n              const message = smsTemplate\n                .replace('{studentName}', formattedRecord.studentName)\n                .replace('{gradeLevel}', formattedRecord.gradeLevel || 'N/A')\n                .replace('{section}', formattedRecord.section || 'N/A')\n                .replace('{scanTime}', formattedRecord.scanTime || new Date().toISOString())\n\n              const smsSent = await sendSms(toPhone, message)\n              console.log('SMS notify result:', smsSent)\n            }\n          } else {\n            console.log('No parent phone found for student, skipping SMS')\n          }\n        }\n      } catch (smsError) {\n        console.error('SMS notification error:', smsError)\n      }\n\n      return NextResponse.json({\n        success: true,\n        record: formattedRecord,\n        message: `Time ${scanType === 'timein' ? 'In' : 'Out'} recorded successfully`,\n      }, {\n        status: 200,\n        headers: postHeaders,\n      })\n  } catch (error: any) {\n    // Catch any unhandled errors that might cause 500 HTML response (for Vercel)\n    console.error('CRITICAL: Unhandled error in POST handler:', error)\n    console.error('Error stack:', error?.stack)\n    console.error('Error name:', error?.name)\n    console.error('Error message:', error?.message)\n    \n    // Always return JSON, never HTML (works for both localhost and Vercel)\n    return NextResponse.json({\n      success: false,\n      error: process.env.NODE_ENV === 'development' ? error?.message : 'Internal server error',\n      records: [],\n      warning: 'Service error occurred',\n    }, {\n      status: 200,\n      headers: postHeaders,\n    })\n  }\n}\n\n// PUT endpoint to enable timeout mode for 5 seconds\nexport async function PUT(request: Request) {\n  const putHeaders = {\n    'Content-Type': 'application/json',\n    'Access-Control-Allow-Origin': '*',\n    'Access-Control-Allow-Methods': 'GET, POST, PUT, OPTIONS',\n    'Access-Control-Allow-Headers': 'Content-Type',\n  }\n\n  try {\n    const body = await request.json()\n    const { action } = body\n\n    if (action === 'enable-timeout') {\n      // Enable timeout mode for 5 seconds\n      const now = Date.now()\n      const expiry = now + 5000 // 5 seconds from now\n      const timestamp = now\n      \n      timeoutModeExpiry.set(timestamp, expiry)\n      \n      console.log('‚è∞ Timeout mode enabled for 5 seconds')\n      \n      return NextResponse.json(\n        {\n          success: true,\n          message: 'Timeout mode enabled for 5 seconds',\n          expiresAt: expiry,\n        },\n        {\n          status: 200,\n          headers: putHeaders,\n        }\n      )\n    } else {\n      return NextResponse.json(\n        {\n          success: false,\n          error: 'Invalid action',\n        },\n        {\n          status: 400,\n          headers: putHeaders,\n        }\n      )\n    }\n  } catch (error: any) {\n    console.error('Error in PUT handler:', error)\n    return NextResponse.json(\n      {\n        success: false,\n        error: error?.message || 'Internal server error',\n      },\n      {\n        status: 200,\n        headers: putHeaders,\n      }\n    )\n  }\n}\n"],"names":[],"mappings":"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"}}]
}